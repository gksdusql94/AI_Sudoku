# -*- coding: utf-8 -*-
"""driver_3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uuugToyYvU5MD3qM1LlucA-qVw2SquBf
"""

#!/usr/bin/env python
#coding:utf-8
"""
Each sudoku board is represented as a dictionary with string keys and
int values.
e.g. my_board['A1'] = 8
"""
import sys

ROW = "ABCDEFGHI"
COL = "123456789"


def print_board(board):
    """Helper function to print board in a square."""
    print("-----------------")
    for i in ROW:
        row = ''
        for j in COL:
            row += (str(board[i + j]) + " ")
        print(row)

def board_to_string(board):
    """Helper function to convert board dictionary to string for writing."""
    ordered_vals = []
    for r in ROW:
        for c in COL:
            ordered_vals.append(str(board[r + c]))
    return ''.join(ordered_vals)

def is_valid_move(solve_board, row, col, num):
    # Check if the same number appears in the same row
    for x in range(9):
        if solve_board[ROW[row] + COL[x]] == num:
            return False

    # Check if the same number appears in the same column
    for x in range(9):
        if solve_board[ROW[x] + COL[col]] == num:
            return False

    # Check if the same number appears in the 3x3 box
    '''For instance, if row is 5, dividing it by 3 leaves a remainder of 2.
    Therefore, 'r_start' is computed as 5 - 2, resulting in 3 being assigned to it.
    This indicates that the fifth row belongs to the first row of the corresponding 3x3 box.'''
    r_start = row - row % 3
    c_start = col - col % 3
    for i in range(3):
        for j in range(3):
            if solve_board[ROW[i + r_start] + COL[j + c_start]] == num:
                return False

    return True

"""The solution function performs backtracking recursively."""

def solution(solve_board, row, col): #Backtracking search: solution/ The solution function performs backtracking recursively.
    # Check if we have reached the last row and column, indicating completion of the puzzle
    N = len(ROW)
    if row == N - 1 and col == N:
        return True #return True indicates a successful backtracking

    # Move to the next row if the current column has reached the end
    if col == N:
        row += 1
        col = 0

    # If the current cell is already populated, move to the next column
    if solve_board[ROW[row] + COL[col]] > 0:
        return solution(solve_board, row, col + 1)

    # Try placing numbers from 1 to 9 in the current empty cell
    for num in range(1, N + 1):
        # Check if it is valid to place the number in the current position
        if is_valid_move(solve_board, row, col, num):
            # If it's valid, assign the number to the current cell
            solve_board[ROW[row] + COL[col]] = num
            # Recursively try to solve the puzzle for the next column
            if solution(solve_board, row, col + 1):
                return True
            # If the puzzle cannot be solved for the next column, backtrack by resetting the current cell to 0
            solve_board[ROW[row] + COL[col]] = 0

    # If no number leads to a valid solution, return False, indicating that the puzzle cannot be solved with the current configuration
    return False #return False indicates failure

def backtracking(board):
    """Takes a board and returns solved board."""
    # TODO: implement this
    solved_board = board
    if solution(solved_board, 0, 0):
        print('solved')
    else:
        print('Unsolved')
    return solved_board

if __name__ == '__main__':
    if len(sys.argv) > 1:
        # Running sudoku solver with one board $python3 sudoku.py <input>.
        input = sys.argv[1]
        if len(input) != 81:
            print("Invalid input string. Please provide 81 characters.")
            exit()

        # Parse boards to dict representation, scanning board L to R, Up to Down
        board = {ROW[r] + COL[c]: int(input[9 * r + c])
                 for r in range(9) for c in range(9)}

        solved_board = backtracking(board)

        # Write board to file
        out_filename = 'output.txt'
        outfile = open(out_filename, "w")
        outfile.write(board_to_string(solved_board))
        outfile.write('\n')

    else:
        # Running sudoku solver for boards in sudokus_start.txt $python3 sudoku.py

        # Read boards from source.
        src_filename = 'sudokus_start.txt'
        try:
            srcfile = open(src_filename, "r")
            sudoku_list = srcfile.read()
        except:
            print("Error reading the sudoku file %s" % src_filename)
            exit()

        # Setup output file
        out_filename = 'output.txt'
        outfile = open(out_filename, "w")

        # Solve each board using backtracking
        for line in sudoku_list.split("\n"):
            if len(line) < 9:
                continue

            # Parse boards to dict representation, scanning board L to R, Up to Down
            board = {ROW[r] + COL[c]: int(line[9*r+c])
                     for r in range(9) for c in range(9)}

            # Print starting board. TODO: Comment this out when timing runs.
            print_board(board)

            # Solve with backtracking
            solved_board = backtracking(board)

            # Print solved board. TODO: Comment this out when timing runs.
            print_board(solved_board)

            # Write board to file
            outfile.write(board_to_string(solved_board))
            outfile.write('\n')

        print("Finishing all boards in file.")